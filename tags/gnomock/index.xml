<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gnomock on Yury Fedorov</title>
    <link>https://fedorov.dev/tags/gnomock/</link>
    <description>Recent content in gnomock on Yury Fedorov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Sep 2020 17:34:33 +0300</lastBuildDate><atom:link href="https://fedorov.dev/tags/gnomock/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Integration testing of Go programs that use Kafka</title>
      <link>https://fedorov.dev/posts/2020-09-26-go-kafka-integration-testing-gnomock/</link>
      <pubDate>Sat, 26 Sep 2020 17:34:33 +0300</pubDate>
      
      <guid>https://fedorov.dev/posts/2020-09-26-go-kafka-integration-testing-gnomock/</guid>
      <description>Kafka message broker is a popular choice for Go programs that require high performance and great scalability. In this post I&amp;rsquo;m going to demonstrate an easy way to build integration tests for such applications. These tests won&amp;rsquo;t need any mocks: they use a real Kafka instance under the hood, giving the most confidence that everything works correctly.</description>
    </item>
    
    <item>
      <title>Code coverage in end-to-end/integration Go tests</title>
      <link>https://fedorov.dev/posts/2020-06-27-golang-end-to-end-test-coverage/</link>
      <pubDate>Sat, 27 Jun 2020 23:39:50 +0300</pubDate>
      
      <guid>https://fedorov.dev/posts/2020-06-27-golang-end-to-end-test-coverage/</guid>
      <description>I like writing integration tests for my Go code. They give me confidence that everything works as expected. This was one of the reasons I built Gnomock (an integration and end-to-end toolkit based on Docker): to easily write tests for code that uses databases or other external services, like AWS S3 or Splunk.</description>
    </item>
    
    <item>
      <title>Testing Go&#43;S3 with Gnomock and Localstack</title>
      <link>https://fedorov.dev/posts/2020-04-11-testing-go-s3-gnomock-localstack/</link>
      <pubDate>Sat, 11 Apr 2020 19:05:51 +0300</pubDate>
      
      <guid>https://fedorov.dev/posts/2020-04-11-testing-go-s3-gnomock-localstack/</guid>
      <description>A few months ago I built gompress: a simple utility that takes a location in AWS S3, compresses all the files in it with GZIP, and puts them in another location, also in S3, optionally keeping or removing the original files. It was something I wrote to use once on a large S3 bucket full of uncompressed CSV files, and published it for anyone else who might need it.</description>
    </item>
    
    <item>
      <title>Reading docker container logs with Go</title>
      <link>https://fedorov.dev/posts/2020-03-27-reading-docker-logs-with-go/</link>
      <pubDate>Fri, 27 Mar 2020 23:53:33 +0300</pubDate>
      
      <guid>https://fedorov.dev/posts/2020-03-27-reading-docker-logs-with-go/</guid>
      <description>I recently added a new feature to Gnomock: an option to forward docker container logs to a user-provided io.Writer implementation.
In short, Gnomock spins up popular tools inside temporary docker containers and allows Go applications to run tests against them very easily. Each supported 3rd party tool is a Preset, and anybody can implement any preset they want.</description>
    </item>
    
  </channel>
</rss>
